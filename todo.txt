Example App
- Buttons
  - animate button clicks
  - different color when button is for the selected model
- animating "bones"
- metadesk for asset files
  - Create all path strings at initialization
  - Create enums for these paths
  - What if the path must be dynamically determined ? (eg., User provides file)
- More efficient rendering of text.
  - Since we are rendering to a backubuffer we only need to do this once
  - Instead of passing one quad for the buffer we could pass smaller quads with the written to
    regions, this could be inferred from the vertices set up in Buttons.
    Therefore, we can probably merge those shaders into one draw call.
- Use only one buffer for rendering quads
 #pragma pack(push, 1)
 typedef struct gl_render_quad_data gl_render_quad_data;
 struct gl_render_quad_data
 {
  v3 Vertex;
  v3 Color;
  v2 Min, Max;
  f32 Radius;
 };
 #pragma pack(pop)
- UI needs previous frame layout to query things like was this button pressed

- Infinite Button list
- Linux platform:
  - for input events, make sure we only get one event per frame.
  - loop editing
- VSync
- Android:
  - Hot reload shared libraries ?

Misc
- metadesk for build targets
- hot reloading for asset files in debug mode
  - store hash of asset file + last write time
      if last_write_time != last_modified
        if old_hash != hash
          reload file
        last_write_time = last_modified

Base
- tag calls with callstack
- better profiler

Archived
x Mouse dragging
x UI scrollable Button list
x Build buttons and render after.
x Investigate button drawing performance.
  - Font rasterizing is taking up most of the time.
x Path from exe -> simplify
x adress sanitizer for arena's
x Android platform layer